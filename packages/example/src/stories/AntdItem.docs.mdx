import { Canvas, Controls, Meta } from '@storybook/addon-docs/blocks';
import Table, { TBody, Td, Th, Thead, Tr } from '@/components/Table';
import AntdItem from './AntdItem';
import AntdItemStories, {
  FormAsync,
  FormEmit,
  FormList,
  FormRate,
  FormSchema,
  FormUpdate,
  FormUpdateFields,
} from './AntdItem.stories';
import './assets/story-styles.css';
import ListObserver from './components/ListObserver';
import TableList from './components/TableList';
import Tag from './components/Tag';

<Meta component={AntdItem} of={AntdItemStories} />

# 扩展 `Antd` 的 `Form` 组件能力

## 介绍

这是一个用 `@event-chat/core` 扩展 `Antd Form` 组件的库。

是否遇到过这样的场景：

- 当更新字段 `A` 的时候，字段 `B` 需要根据 `A` 的结果做出反应
- 一个字段的值要在不同业务交互下，根据配置做出相应反应
- 不同的业务需要经过不同的逻辑交付相同类型的字段

现有的 `antd` 有这么几个问题：

- 受控能力有限，不能对每次设置做出精准的反应
- 不同的业务场景下，需要写多套逻辑，且不能复用
- 表单交互逻辑无法解耦，多个无关的 `state` 堆砌在一个组件中

`@event-chat/antd-item` 目的就是为抽离这块逻辑，能够解耦表单交互，让组件最小到字段去单独处理逻辑

## 安装

`@event-chat/antd-item` 允许单独安装，建议搭配 `zod` 和 `@event-chat/core`，因为 `zod` 可以提供字段接受的类型，而 `@event-chat/core` 允许在封装之外更灵活的自定义表单交互 [[查看](/docs/document-eventchat--docs)]。

```shell
# npm
npm install @event-chat/item

# yarn
yarn add @event-chat/item

# pnpm
pnpm add @event-chat/item
```

## 目录

<ListObserver />

## 基础使用示例

<Canvas
  className="doc-render"
  additionalActions={[
    {
      title: 'Code in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/event-chat/event-chat/blob/main/packages/example/src/module/form/FormEmit.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={FormEmit}
  sourceState="none"
/>

`antd` 的 `setFieldValue` 将作为手动更新，不会被 `dependencies` 监听，而通过 `formEvent` 向受控字段通过 `emit` 触发更新，指定字段会通过 `onChange` 模拟自然更新从而被精准捕获到更新。

`emit` 的方法见 `@event-chat/core` [[查看](#tag1)]，`@event-chat/antd-item` 会收集：

- 表单每个字段名作为事件名，用于收集传递的信息
- `Form` 组件的 `name` 作为表单以及表单字段的 `group`，用于区别同时存在的多个表单

## API 参数

扩展了 `antd Form` 组件，大致如下：

- 扩展子组件：`Item`、`List`
- 扩展方法：`useForm`、`useFormInstance`
- 扩展实例：`FormInstance`
- 补充方法 `observer`：允许业务提供组件，便于统一上下文

### `Form`

沿用 `Form` 组件原有的属性，通过透传的方式赋予表单的能力。除此之外做了以下补充：

<TableList
  data={[
    {
      desc: (
        <>
          扩展 <Tag>Antd Form</Tag> 原有的实例 <Tag>FormInstance</Tag>，见下方说明 [<a>查看</a>
          ]，接收提供未扩展的 <Tag>FormInstance</Tag> 实例，会在内部补充实例属性
        </>
      ),
      keyname: 'form',
      type: ['FormEventInstance<Name, Group>', 'undefined'],
    },
    {
      desc: '用于区别多个表单的情况',
      keyname: 'global',
      type: ['string', 'undefined'],
    },
    {
      desc: (
        <>
          沿用 <Tag>Antd Form</Tag> 现有的属性 <Tag>name</Tag>，用于向表单下任意字段发起更新。
        </>
      ),
      keyname: 'name',
      type: ['string', 'undefined'],
    },
  ]}
/>

### `Form.Item`

沿用 `Form.Item` 组件原有的属性，通过透传的方式赋予表单项的能力。除此之外做了以下补充：

<TableList
  data={[
    {
      desc: (
        <>
          当表单字段接收类型受异步 <Tag>schema</Tag> 约束时需要一同配置
        </>
      ),
      keyname: 'async',
      type: ['boolean', 'undefined'],
    },
    {
      desc: (
        <>
          表单字段名，同时也用于接收事件。对于 <Tag>Form.List</Tag> 下的 <Tag>Form.Item</Tag>
          ，会自动补全字段名。字段名的类型在扩展时做了约束，见下方说明。
        </>
      ),
      keyname: 'name',
      type: ['NamepathType'],
    },
    {
      desc: (
        <>
          表单字段接收的数据类型，不提供时接收的数据类型为 <Tag>unknown</Tag>。自然输入时配置{' '}
          <Tag>schema</Tag> 将会默认补充一条 <Tag>Rule</Tag> 作为字段校验的规则
        </>
      ),
      keyname: 'schema',
      type: ['ZodType', 'undefined'],
    },
    {
      desc: (
        <>
          透传至 <Tag>useEventChat</Tag> 的选项属性 <Tag>callback</Tag>，用于响应字段更新
          。除此之外，回调函数中会追加字段的 <Tag>emit</Tag> 作为第二个参数，便于继续受控后操作。
        </>
      ),
      keyname: 'callback',
      type: ['Function', 'undefined'],
    },
    {
      desc: (
        <>
          透传至 <Tag>useEventChat</Tag> 的选项属性 <Tag>debug</Tag>
          。调试时用于收集所有未匹配字段规则的消息
        </>
      ),
      keyname: 'debug',
      type: ['Function', 'undefined'],
    },
    {
      desc: (
        <>
          和 <Tag>callback</Tag> 一样用于响应字段更新。
          <Tag>onChange</Tag> 按照 <Tag>Antd</Tag> 表单规则，会透传到字段内部表单组件中，将{' '}
          <Tag>callback</Tag> 回调中的 <Tag>detail</Tag> 作为参数更新字段，同样也提供第二个参数{' '}
          <Tag>emit</Tag>
        </>
      ),
      keyname: 'onChange',
      type: ['Function', 'undefined'],
    },
    {
      desc: (
        <>
          将原有的 <Tag>Form.Item</Tag> 中的 <Tag>rules</Tag> 类型中提取一项 <Tag>transform</Tag>
          ，用于搭配 <Tag>schema</Tag> 转换字段数据后用于 <Tag>Rule</Tag> 自身校验用。
        </>
      ),
      keyname: 'transform',
      type: ['(value: unknown) => unknown'],
    },
  ]}
/>

`NamepathType` 类型：

```typescript
type NamepathType = number | string | Array<string | number> | Readonly<Array<string | number>>;
```

`onChange` 类型：

```typescript
onChange?: (
    value: Parameters<
      NonNullable<EventChatOptions<NamepathType, Schema, string, Type, undefined>['callback']>
    >[0]['detail'],
    options: ReturnType<typeof useEventChat>
  ) => void;
```

> 原来的 `Form.Item` 的子组件如果是一个函数时，会将 `FormInstance` 作为回调函数。由于扩展了实例 `FormInstance`，回调函数中 `form` 实例将包含：`name`、`group`、`emit` [[查看](tag2)]。

扩展的 `Form.Item` 包含 2 个 `onChange`，一个是 `Antd` 表单组件本身自带的 `onChange`，一个是通过 `@event-chat/core` 扩展 `Form.Item` 后补充的 `onChange`，两者差异：

<Table className={{ wrap: 'sb-unstyled' }}>
  <Thead>
    <Tr>
      <Th className="w-50 bg-gray-100" sticky>
        对比 <Tag type="info">onChange</Tag>
      </Th>
      <Th>
        <Tag type="info">Form.Item</Tag> 扩展
      </Th>
      <Th>表单组件现有的</Th>
    </Tr>
  </Thead>
  <TBody>
    <Tr>
      <Td>所属组件</Td>
      <Td>
        <Tag>Form.Item</Tag>
      </Td>
      <Td>
        表单组件，例如：<Tag>Input</Tag>
      </Td>
    </Tr>
    <Tr>
      <Td>场景</Td>
      <Td>
        通过 <Tag>emit</Tag> 触发
      </Td>
      <Td>
        收集自然输入更新的值，在表单组件内部通过 <Tag>onChange</Tag> 触发
      </Td>
    </Tr>
    <Tr>
      <Td>数据校验</Td>
      <Td>
        更新数据前校验，若配置了 <Tag>schema</Tag> 则拿到的数据一定符合预期，更新后的字段不会触发{' '}
        <Tag>Rule</Tag> 校验
      </Td>
      <Td>
        更新数据后通过 <Tag>Rule</Tag> 校验，更新的值不一定符合预期
      </Td>
    </Tr>
  </TBody>
</Table>

`Form.Item` 扩展的 `onChange` 和表单组件的 `onChange` 一样的地方：

- 通过 `setFieldValue` 手动设置的值都不响应
- 都会响应后更新字段数据，并触发相应操作，如：`getValueFromEvent`
- 提交表单时，更新的数据都会再次校验，不符合要求的情况会被拦截操作

> 由于触发的场景不一样，因此自然输入的时候会交由表单组件更新并触发 `onChange`，`emit` 则是手动触发，会在 `Form.Item` 更新值并回调 `onChange`，为了避免混淆，并没有合并回调方法，这两个方法也不存在同时触发的场景。

由于以上特性，因此建议：

- 多个字段间存在主控和受控关系时，使用 `emit` 代替 `setFieldValue` 等默认的手动设置方法

### `Form.List`

沿用 `Form.List` 组件原有的属性，通过透传的方式赋予表单列表项的能力。

列表项扩展的属性和上述的 `Form.Item` 一致。它们的内部都是通过增加一个同字段名的 `Form.Item` 来捕获并触发更新。

### `Form.useForm`

沿用 `useForm` 原本的能力，返回的 `FormInstance` 补充以下属性：

<TableList
  data={[
    {
      desc: '表单所属群组',
      keyname: 'group',
      type: ['string', 'undefined'],
    },
    {
      desc: '用于向表单下任意字段发起更新',
      keyname: 'name',
      type: ['string', 'undefined'],
    },
    {
      desc: (
        <>
          用于向表单字段发起更新的方法，详细见 <Tag>@event-chat/core</Tag> [<a>查看</a>]
        </>
      ),
      keyname: 'emit',
      type: ['Function', 'undefined'],
    },
  ]}
/>

`Form.useForm` 和 `Antd` 现有的方法一样，允许在创建表单组件之前，声明一个 `FormInstance`，通过属性 `form` 提供给 `Form` 组件，以便在外层对表单进行操作。

补充的属性和方法见 `@event-chat/core` [[查看](#tag1)]

参数：

<TableList
  data={[
    {
      desc: (
        <>
          配置项，允许提供 <Tag>group</Tag> 或 <Tag>name</Tag>
        </>
      ),
      keyname: 'options',
      type: ['FormOptions<Name, Group>', 'undefined'],
    },
    {
      desc: (
        <>
          可以提供一个 <Tag>FormInstance</Tag>，将其转变为 <Tag>FormEvent</Tag> 可用的实例
        </>
      ),
      keyname: 'formInit',
      type: ['FormEventInstance<Name, Group>', 'undefined'],
    },
  ]}
/>

`FormOptions` 会根据提供的配置，扩充返回的 `FormInstance` 实例，类型如下：

```typescript
type FormOptions<Name extends NamepathType, Group extends string | undefined = undefined> = {
  group?: Group;
  name?: Name;
};
```

`formInit` 允许提供一个 `FormInstance` 实例，可以是扩展前的实例，也是扩展后的实例：

- `name`、`group`：若提供的实例已包含属性，则优先采用实例本身的属性
- `emit`：无论是否提供都会重新声明并覆盖

`Form.useForm` 和 `Form` 组件，都允许提供 `name` 和 `group` 扩充 `FormInstance`，优先级如下：

- `name`：优先 `Form` 提供的属性，因为这是 `antd` 自身的属性
- `group`：优先 `Form.useForm` 提供的属性

### `Form.useFormInstance`

沿用 `useFormInstance` 原本的能力，允许在表单下的子组件中，返回 `FormInstance` 并补充以下属性：

<TableList
  data={[
    {
      desc: '表单所属群组',
      keyname: 'group',
      type: ['string', 'undefined'],
    },
    {
      desc: '用于向表单下任意字段发起更新',
      keyname: 'name',
      type: ['string', 'undefined'],
    },
    {
      desc: (
        <>
          用于向表单字段发起更新的方法，详细见 <Tag>@event-chat/core</Tag> [<a>查看</a>]
        </>
      ),
      keyname: 'emit',
      type: ['Function', 'undefined'],
    },
  ]}
/>

需要说明的是 `Form.useFormInstance` 扩展的属性全部为可选值，因为是通过上下文获取，如果没有在 `FormEvent` 内部使用，的确可能拿到的是 `undefined`。使用的时候需要通过 `?.` 来调用，例如：`form?.emit`。

### `FormInstance`

由 `Form.useForm` 或 `Form.useFormInstance` 返回的 `form` 实例，扩展实例的属性如上所述。为了兼容 `Antd v5` 和 `Antd v6`，将实例中的方法 `focusField` 作为可选属性，由业务环境依赖决定。

### `observer`

补充的一个方法，用于对齐 `antd` 在业务和库之间的上下文，例如：主题、配色等。通常情况上下文应该是一个，但由的情况，例如：`monorepo` 各个包下依赖的环境不一样的时，导致上下文不一致，于是提供一个全局方法，用法如下：

```typescript
// root component
import FormEvent from '@event-chat/antd-item';
import { Form } from 'antd';

FormEvent.observer(Form);
```

这样所有子组件引入的 `Form` 全部来自业务提供的 `Form`。原本作为组件库要打通组件上下文，通常是将 `antd` 从库内部引入再统一提供给外部，但这次扩展只针对 `Form` 组件，于是做了一个中间层

```typescript
import { Form } from 'antd';

export const AntdCom: {
  form?: FormBaseInstance;
} = {};

const observer = (FormCom: FormBaseInstance): void => {
  AntdCom.form = FormCom;
};

const useFormCom = (): FormBaseInstance => {
  return AntdCom.form ?? Form;
};
```

所有扩展的组件内部通过 `useFormCom` 根据配置，获取最终的组件。

> `@event-chat/antd-item` 允许和 `antd` 结合搭配一起用，可以在需要触发受控的字段 `emit`，在受控字段使用 `Antd` 原本的表单组件。扩展的目的是为了更好的完成业务，并非 `antd` 的能力补充。

## 监听表单数据更新

<Canvas
  additionalActions={[
    {
      title: 'Code in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/event-chat/event-chat/blob/main/packages/example/src/module/form/FormUpdate.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={FormUpdate}
  sourceState="none"
/>

> 官方文档：`change` 事件仅当用户交互才会触发。该设计是为了防止在 `change` 事件中调用 `setFieldsValue` 导致的循环问题。

官方的建议是：

- 通过 `useWatch` 实现字段监听，缺点是 `Form.List` 动态删减字段时可能会引发报错，这个错误可能不是业务代码能够修复的，只能调整业务逻辑
- 也可以通过 `shouldUpdate` 做全局更新，缺点是无法精准判断更新的具体字段

`emit` 允许被 `onFieldsChange` 和 `onValuesChange` 监听到，但同样会将官方提出的问题暴露给业务方：

- 在 `change` 内部需要避免循环更新，尤其是循环嵌套触发的更新
- 这个问题业务可以在代码层面去做调整修复，而不会因为底层的限制需要调整业务逻辑
- 优点是能够精准触发，监听更新的具体字段

## 通过表单向指定字段发起更新

<Canvas
  additionalActions={[
    {
      title: 'Code in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/event-chat/event-chat/blob/main/packages/example/src/module/form/FormUpdateFields.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={FormUpdateFields}
  sourceState="none"
/>

`Antd` 原有的 `form.setFieldsValue` 只能主动更新指定值，字段不能被动更新。在表单项子组件中通过 `emit` 向表单发起字段更新会被受控字段监听到。

## 追踪列表项更新

<Canvas
  additionalActions={[
    {
      title: 'Code in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/event-chat/event-chat/blob/main/packages/example/src/module/form/FormList.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={FormList}
  sourceState="none"
/>

设置列表项的具体值，并希望追踪更新的值做出相应的反应。`Antd` 原有的能力需要根据业务逻辑挨个赋值，而 `emit` 允许将赋值和受控分离开，当指定表单项更新后受控字段再做出反应。

> 在 `Form.List` 下的 `Form.Item` 会自动收集列表的 `name`，将自动合并列表项自身的 `name`。`emit` 触发更新时，需要完整填写 `namePath`。

在上面的演示案例中，分别展示了：

- 通过 `Form.useForm` 申明一个扩展的表单实例，触发 `emit` 更新
- 通过 `For.useFormInstance` 从上下文中拿到扩展的表单实例，向表单触发 `emit` 更新字段
- 在受控字段中通过 `onChange` 回调拿到 `emit` 触发更新

下面会对 `@event-chat/antd-item` 扩展特性进行演示

## 扩展的特性

### 指定受控字段类型

通过 `Schema` 指定受控字段的类型，只有符合条件的消息会触发字段更新。同时提供 `debug` 作为调试函数，用于收集未匹配的数据。

<Canvas
  additionalActions={[
    {
      title: 'Code in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/event-chat/event-chat/blob/main/packages/example/src/module/form/FormSchema.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={FormSchema}
  sourceState="none"
/>

这样 `Antd` 表单字段实现了按照指定类型受控，一个字段可以在不同的业务场景下复用，而最终的交付结果一定是按照最初定义的 `Schema` 相匹配。

> 比如有个字段叫 `userLevel`，类型为：`{ type: string; power: number; }`，那么这个字段在用户录入的表单里是这个类型，在新增管理员的表单里也一定是这个类型。

### 转换字段数据进行渲染

根据上方 `schema` 演示，可以将字段让字段赋值变得更加简单，而渲染更加复杂。

<Canvas
  additionalActions={[
    {
      title: 'Code in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/event-chat/event-chat/blob/main/packages/example/src/module/form/FormRate.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={FormRate}
  sourceState="none"
/>

提供了 5 种方法用于数据类型转换，按照生命周期划分分别如下：

- `ZodType.transform`：校验数据成功后转换数据，将结果通过 `onChange` 发起更新
- `getValueFromEvent`：`Antd` 现有的属性，用于接收 `onChange` 的值更新字段
- `normalize`：同 `getValueFromEvent`
- `FormItem.transform`：补充方法，仅用于通过 `schema` 校验表单数据前转换用，不会改变字段值
- `getValueProps`：`Antd` 现有的属性，用于将更新的数据转换成符合回显要求的数据

根据自己的业务选择适合的方式，这里提供了 2 个演示：

- 前提：不同的业务场景下，同类型字段组件，`emit` 触发更新都是数字，不改组件，不改配置规则；
- 第 1 个演示：怎么收集数据，怎么提交，但会把收集的数据重新转换成渲染匹配的数据；
- 第 2 个演示：拿到数值，转换成渲染一致的格式提交；

> 需要注意的是：`Form.List` 除了 `ZodType.transform` 以外都不支持，为了减少业务的复杂度，不建议对 `Array` 这样的字段类型做数据转换，可以对 `List` 下的 `Item` 做数据转换

### 分段 + 异步验证自身字段

当提供 `schema` 后，会自动将其作为一项字段校验的 `Rule` 添加到字段中。

<Canvas
  additionalActions={[
    {
      title: 'Code in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/event-chat/event-chat/blob/main/packages/example/src/module/form/FormAsync.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={FormAsync}
  sourceState="none"
/>

当前示例分别演示了：

- `pipe`：通过管道分段校验，中途错误将不再继续
- `async`：异步校验，当需要做异步校验时，字段的状态可以在 `refine` 中定义

## 类型对齐

`@event-chat/core` 作为 `Antd Form` 的 `@event-chat/core` 的扩展，自然要对齐这二者的类型。

### 摒弃部分泛型

在 `@event-chat/core` 中将不必要的参数做了简化：

- 摒弃了部分配置：表单字段由 `Form` 分配 `group`，不能够自定义配置
- 泛型推导只保留了：`schema` 和 `name`，表单 `Form` 组件保留了 `Group`，其他全部给到默认值

### 对内简化 `Form` 类型

为了扩展并且跨版本支持 `Antd Form`，在内部按照扩展必要用到的属性做了一个通用的简化的 `Form` 类型

```typescript
type FormType<ValueType = unknown> = (
  props: Pick<ComponentProps<typeof Form<ValueType>>, 'children' | 'form' | 'name'> &
    React.RefAttributes<FormInsType<ValueType>>
) => React.ReactElement;

type FormBaseInstance<ValueType = unknown> = FormType<ValueType> & {
  Item: FC<
    Pick<FormItemProps, 'hidden' | 'initialValue' | 'name' | 'rules'> & {
      children?: ReactNode | ((form: FormInsType<ValueType>) => ReactNode);
    }
  >;
  List: FC<Pick<ComponentProps<typeof Form.List>, 'children' | 'initialValue' | 'name' | 'rules'>>;
  useFormInstance: <Value>() => FormInsType<Value>;
};

type FormInsType<ValueType = unknown> = Omit<
  NonNullable<ComponentProps<typeof Form<ValueType>>['form']>,
  'focusField'
> & {
  focusField?: NonNullable<ComponentProps<typeof Form>['form']>['focusField'];
};
```

只能符合基本要求的类型，都视为有效的 `Form` 组件。同时为了跨版本支持， 去除了 `Antd v6` 实例 `FormInstance` 中的 `focusField` 改为可选属性，由业务决定属性是否存在。

### 扩展 `Antd` 的泛型

在 `Antd Form` 泛型中需要补齐 `Name` 和 `Schema`，这里存在一个问题：

- `Typescript` 泛型中要么全部隐式推导，要么全部手动显示提供，若前面的手动提供，后面带有默认类型的泛型将不再隐式推导，而全部采用默认类型。

于是在每个组件泛型中，将 `ValueType` 放到最后，避免因未提供其他类型造成错误

```typescript
// Form 扩展后的类型
const FormEvent: (<Name extends string, Group extends string | undefined = undefined, ValuesType = unknown>({ children, form, group, name, ...props }: PropsWithChildren<FormProps<Name, Group, ValuesType>>) => JSX.Element) & FormExtraInstance

// Form.Item 扩展后的类型
const Item: <Name extends NamepathType, Schema extends ZodType | undefined = undefined, ValueType = unknown>({ async, children, initialValue, name, rules, schema, type, callback, debug, onChange, transform, ...props }: FormItemProps<Name, Schema, ValueType>) => JSX.Element

// useForm 扩展后的类型
const useForm = <
  Name extends string,
  Group extends string | undefined = undefined,
  ValueType = unknown,
>() => {
  // 略...
}
```

`useFormInstance` 提供的泛型保持不变，`Form.List` 无需提供泛型

### 对外合并扩展

为了保持一致，导出的出口文件 `index.tsx` 做了和 `Antd` 一致的事，将所有扩展方法全部合并到 `Form`

```typescript
const FormEvent: typeof FormEventInner & FormExtraInstance = Object.assign(FormEventInner, {
  Item: FormItem,
  List: FormList,
  observer,
  useForm,
  useFormInstance,
});
```
