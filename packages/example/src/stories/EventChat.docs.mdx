import { ArgsTable, Canvas, Controls, Description, Meta } from '@storybook/addon-docs/blocks';
import EventChat from './EventChat';
import EventChatStories, { Default, Group, Schema, Token } from './EventChat.stories';
import './assets/story-styles.css';
import ListObserver from './components/ListObserver';
import TableList from './components/TableList';
import Tag from './components/Tag';

<Meta
  component={EventChat}
  of={EventChatStories}
  parameters={{
    layout: 'centered',
    // 可选：补充文档相关参数，确保 autodocs 正常生效
    docs: {
      description: {
        component: '这是 EventChat 组件的详细文档，用于展示 Hooks 特性。',
      },
    },
  }}
  title="useEventChat"
/>

# `useEventChat`: 组件通信 `Hooks`

## 介绍

- 提供名字和回调方法，`Hooks` 会返回一个 `emit`
- 用 `emit` 可以向指定名称发送消息，也可以给事件名提供 `callback` 用于接收消息
- 无论是否是父子层级都能相互通信，不会引发不必要的 `rerender`

## 安装

```shell
# npm
npm install @event-chat/core

# yarn
yarn add @event-chat/core

# pnpm
pnpm add @event-chat/core
```

## 目录

<ListObserver />

## 基础使用示例

<Canvas
  additionalActions={[
    {
      title: 'Pub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/PubNoLimit.tsx',
          '_blank'
        );
      },
    },
    {
      title: 'Sub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/SubNoLimit.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={Default}
  sourceState="none"
/>

## API 参数

<Controls />

> 参数 `options` 的类型，切换上方 `tab` 至 `EventChatOptions` 查看，返回的类型切换至 `EventChatResult`

### `callback`：回调函数

回调函数的参数类型如下：

<TableList
  data={[
    {
      desc: (
        <>
          根据配置 <Tag>schema</Tag> 推导具体类型，没有提供则为 <Tag>unknown</Tag>
        </>
      ),
      keyname: 'detail',
      type: ['Schema', 'unknown'],
    },
    {
      desc: (
        <>
          收到的消息是否发有发送到公屏，来自 <Tag>emit</Tag>
        </>
      ),
      keyname: 'global',
      type: ['boolean', 'undefined'],
    },
    {
      desc: (
        <>
          根据配置 <Tag>group</Tag> 推导具体类型，没有提供则为 <Tag>unknown</Tag>
        </>
      ),
      keyname: 'group',
      type: ['Group', 'undefined'],
    },
    { desc: '内部生成的唯一字符', keyname: 'id', type: ['string'] },
    {
      desc: (
        <>
          接收消息的事件名，根据配置 <Tag>name</Tag> 推导具体名称
        </>
      ),
      keyname: 'name',
      type: ['NamepathType'],
    },
    { desc: '发送消息的事件名', keyname: 'origin', type: ['NamepathType'] },
    {
      desc: (
        <>
          根据配置 <Tag>token</Tag> 为 <Tag>true</Tag> 时类型为 <Tag>string</Tag>，否则为{' '}
          <Tag>undefined</Tag>
        </>
      ),
      keyname: 'token',
      type: ['string', 'undefined'],
    },
    {
      desc: (
        <>
          根据配置 <Tag>type</Tag> 推导具体类型，没有提供则为 <Tag>unknown</Tag>
        </>
      ),
      keyname: 'type',
      type: ['Type', 'undefined'],
    },
  ]}
/>

其中 `group` 和 `token` 将会根据接收消息的配置决定收到的值

- 接收消息没有配置 `group`，回调函数 `callback` 参数中的 `group` 为 `undefined`
- 接收消息 `token` 不为 `true`，回调函数 `callback` 参数中的 `token` 为 `undefined`

> 也就意味着，即便发送消息时通过 `global` 发送到“公屏“，同时也提供了 `group` 和 `token`，但接收方没有配置，那么回调函数中 `group` 和 `token` 为 `undefined`

### `debug`：调试方法

接收的参数来自 `zod` 校验失败后的对象

```typescript
type ResultType<Schema = unknown> = Omit<z.ZodSafeParseError<Schema>, 'data'> & {
  data: unknown;
};
```

### `emit`：发送消息的方法

送消息方法的参数类型如下：

<TableList
  data={[
    {
      desc: '发送的消息内容，可以是任意值，这里作为泛型进行收集。只有接收方匹配才能收到消息',
      keyname: 'detail',
      type: ['Detail', 'undefined'],
    },
    {
      desc: '用于群组成员是否发送消息到公屏',
      keyname: 'global',
      type: ['boolean', 'undefined'],
    },
    {
      desc: '接收消息的事件名',
      keyname: 'name',
      type: ['NamepathType'],
    },
    {
      desc: '接收事件消息的密钥',
      keyname: 'token',
      type: ['string', 'undefined'],
    },
  ]}
/>

额外说明：

- `group`、`token` 仅用于接收方比对，接收方最终根据自身配置，透传给 `callback` 作为参数
- `id` 为内部生成
- `origin`、`type` 将根据 `useEventChat` 配置自动添加

### `NamepathType`：事件名

类型如下，可以接受字符、数值、以及字符和数值的元祖：

```ts
type NamepathType = number | string | Array<string | number> | Readonly<Array<string | number>>;
```

- 可以定义为字符名称：`pub-mox`（推荐，简单直接推导）
- 可以定义为通过 `.` 划分的 `namepath`：`pub.mox`（例如 `formily` 的路径结构）
- 可以定义为数组划分的 `namepath`：`['pub', 0, 'mox']`（例如 `antd` 的路径结构）
- 当定义为元祖的时候会丢失原有的可读性，于是允许传递 `readonly` 的元祖维持可读性

> 当设置字符类型的 `namepath` 时，事件名和元祖类型可能不相等。例如：`['pub.mox', 0, 'name']` 和 `pub.mox.0.name` 得到的事件名不相等。

## `schema`：指定消息类型

通过 `Zod` 来实现，提供一个 `schema` 后只有类型匹配的消息才会被接收。

<Canvas
  additionalActions={[
    {
      title: 'Pub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/PubSchema.tsx',
          '_blank'
        );
      },
    },
    {
      title: 'Sub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/SubSchema.tsx',
          '_blank'
        );
      },
    },
    {
      title: 'Toast in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/tree/main/packages/example/src/components/toast',
          '_blank'
        );
      },
    },
  ]}
  of={Schema}
  sourceState="none"
/>

提供 `schema` 后回调函数 `callback` 的参数对象中的属性 `detail`，会根据 `schema` 模型定义的规则推断数据类型。只有类型校验通过的数据才会被接收。所以无论消息怎么发，最终接收的一定是约定好的类型。

### 异步消息

`Zod` 是允许异步校验的，这里通过 `async` 来实现，例如：

```typescript
const { emit } = useEventChat('pub-mox', {
  async: true,
  schema: z.string().refine(async (id) => {
    // verify that ID exists in database
    return true;
  }),
  callback: ({ detail }) => {
    // print id is string
    console.log('a----pub-mox', detail.id);
  },
});
```

通过 `Zod` 的 `refine` 可以实现异步或同步的自定义校验规则，例如 `return type === 'customType'`

## `group`：群组消息

设置 `group` 后将只接受来自成员组的组内消息：

<Canvas
  additionalActions={[
    {
      title: 'Pub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/PubGroupPanel.tsx',
          '_blank'
        );
      },
    },
    {
      title: 'Sub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/SubGroupPanel.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={Group}
  sourceState="none"
/>

### “公屏“喊话

对于组内的成员，如果需要在 “公屏” 喊话，调用 `emit` 时可以提供一个 `global`，这样发送到群组内部的同时会将信息发送到“公屏“同名事件中，例如：

```typescript
useEventChat('pub-mox', {
  callback: (record) => {
    // receive undefined
    console.log('a----pub-mox', record.group);
  },
});

const { emit } = useEventChat('sub-mox', {
  group: 'form-detail-edit',
});
emit({ global: true, name: 'pub-mox' });
```

由于“公屏“同名事件并没有提供 `group`，所以在回调函数的参数中属性 `group` 将得到 `undefined`，除非将其设为组内成员，否则无法拿到 `group` 具体值。

> 发送到“公屏“时，同名非同组的组内事件无法收到消息，组内消息只能组内传递，或通过 `global` 同步发送给非组内的“公屏“同名事件。同理非组内成员除非通过 `group` 设为组内成员，否则无法向组内发送消息。

### 群组成员屏蔽“公屏“

当通过 `global` 向“公屏“发起喊话的同时，群组成员同名事件也会收到相同的消息。是否需要屏蔽群组成员接收来自“公屏“的喊话，这里交由业务来决定，例如：

```typescript
useEventChat('pub-mox', {
  group: 'edit-group',
  callback: ({ global }) => {
    if (!global) {
      // do somethine
    }
  },
});
```

### 同组件同事件名多群组

方式 1：一个组件中可以声明多个 `hooks` 来实现多个群组

考虑过让 `group` 支持类型包含：`string | string[] | undefined`，但这就有两个问题：

- `emit` 时自动附带配置的 `group`，当发送消息时是否希望所有群组都收到相同消息，应由业务决定
- `emit` 也可以发送自定义 `group`，但这样会存在一个问题，`emit` 时添加了自身以外的群组，是直接报错或忽略当前 `detail`？显然业务来决定更合适（这两种方案都不能在接收方通过 `debug` 收集错误，增加了调试复杂度）

> 因此目前来看，如果一个组件要加入多个群组，在同一个业务组件里同时声明多个 `hooks` 更合适。

方式 2：通过 `schema` 做区分

分组过多同组件同事件名，声明不同 `group` 可能会造成业务复杂度上升，通过 `schema` 做区分会更合适，全部示例：

```typescript
useEventChat('multiple-event', {
  group: 'edit-group',
  schema: z.object({
    name: z.string(),
    type: z.enum(['color', 'size', 'byte']),
  }),
  callback: ({ detail }) => {
    if (detail.type === 'color') {
      // 1. manual checked
    }
  },
});

useEventChat('multiple-event', {
  group: 'edit-group',
  schema: z.object({
    name: z.string(),
    type: z.never(),
  }),
  callback: ({ detail }) => {
    // 2. auto checked by schema
  },
});

useEventChat('multiple-event', {
  group: 'other-group',
  schema: z.object({
    name: z.string(),
    type: z.enum(['color', 'size', 'byte']),
  }),
  callback: ({ detail }) => {
    // 3. auto checked by different group names
  },
});
```

## `token`：私信

配置参数 `token: true` 后，将只接受 `emit` 带有对应的 `token` 发送的消息。

<Canvas
  additionalActions={[
    {
      title: 'Pub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/PubPrivate.tsx',
          '_blank'
        );
      },
    },
    {
      title: 'Sub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/SubPrivate.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={Token}
  sourceState="none"
/>

每次创建会话时 `token` 会连同 `emit` 一起返回，将拿到的 `token` 提供给发送方（例如：`props`、`context`...），通过 `emit` 发送消息时携带 `token` 即可发送私信

> 私信发送允许和 `group` 一样，通过 `group` 同时发送到 “公屏“，操作流程见 `group`

### 携带 `token` 发送消息

和接收消息同理，当 `emit` 发送消息携带了 `token` 但没有设置 `global` 的情况下，只能向指定 `token` 对应的接收方发送消息，其他同名事件无法获取到消息。

> `emit` 发送消息时 `group` 和 `token` 一样，不同的是 `group` 按照配置自动携带，而 `token` 需要手动配置

## `debug`：调试

和 `callback` 一样，提供一个 `debug` 回调函数，将收集所有通过 `emit` 发送的同名事件，但未能匹配接收消息的规则，而触发的消息，例如：

```typescript
useEventChat('pub-mox', {
  group: 'form-detail-edit',
  callback: (record) => console.log('a----pub-mox', record),
  debug: (result) => console.log('a----pub-log', result),
});
```

调试方法中的参数 `result` 来自 `z.safeParse` 得到的错误结果，包含了 `emit` 发送的信息，以及错误原因等情况
