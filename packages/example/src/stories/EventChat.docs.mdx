import { ArgsTable, Canvas, Controls, Description, Meta } from '@storybook/addon-docs/blocks';
import EventChat from './EventChat';
import EventChatStories, { Default, Group, Schema } from './EventChat.stories';
import ListObserver from './components/ListObserver';
import TableList from './components/TableList';
import Tag from './components/Tag';

# `useEventChat`: 组件通信 `Hooks`

## 介绍

- 提供名字和回调方法，`Hooks` 会返回一个 `emit`
- 用 `emit` 可以向指定名称发送消息，也可以给事件名提供 `callback` 用于接收消息
- 无论是否是父子层级都能相互通信，不会引发不必要的 `rerender`

<Meta
  component={EventChat}
  of={EventChatStories}
  parameters={{
    layout: 'centered',
    // 可选：补充文档相关参数，确保 autodocs 正常生效
    docs: {
      description: {
        component: '这是 EventChat 组件的详细文档，用于展示 Hooks 特性。',
      },
    },
  }}
  tags={['autodocs']}
  title="useEventChat"
/>

## 目录

<ListObserver />

## 基础使用示例

<Canvas
  additionalActions={[
    {
      title: 'Pub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/PubNoLimit.tsx',
          '_blank'
        );
      },
    },
    {
      title: 'Sub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/SubNoLimit.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={Default}
  sourceState="none"
/>

## API 参数

<Controls />

> 由于 `Storybook` 限制 `useEventChat` 返回的数据类型，切换上方 `tab` 至 `EventChatResult` 查看

### `callback`：回调函数

回调函数的参数类型如下：

<TableList
  data={[
    { desc: '发送消息的事件名', keyname: '__origin', type: ['string'] },
    {
      desc: (
        <>
          根据配置 <Tag>schema</Tag> 推导具体类型，没有提供则为 <Tag>unknown</Tag>
        </>
      ),
      keyname: 'detail',
      type: ['z.output<Schema>', 'unknown'],
    },
    {
      desc: (
        <>
          收到的消息是否发有发送到公屏，来自 <Tag>emit</Tag>
        </>
      ),
      keyname: 'global',
      type: ['boolean', 'undefined'],
    },
    {
      desc: (
        <>
          根据配置 <Tag>group</Tag> 推导具体类型，没有提供则为 <Tag>unknown</Tag>
        </>
      ),
      keyname: 'group',
      type: ['Group', 'undefined'],
    },
    { desc: '内部生成的唯一字符', keyname: 'id', type: ['string'] },
    {
      desc: (
        <>
          接收消息的事件名，根据配置 <Tag>name</Tag> 推导具体名称
        </>
      ),
      keyname: 'name',
      type: ['Name'],
    },
    {
      desc: (
        <>
          根据配置 <Tag>token</Tag> 为 <Tag>true</Tag> 时类型为 <Tag>string</Tag>，否则为{' '}
          <Tag>undefined</Tag>
        </>
      ),
      keyname: 'token',
      type: ['string', 'undefined'],
    },
    {
      desc: (
        <>
          根据配置 <Tag>type</Tag> 推导具体类型，没有提供则为 <Tag>unknown</Tag>
        </>
      ),
      keyname: 'type',
      type: ['Type', 'undefined'],
    },
  ]}
/>

其中 `group` 和 `token` 将会根据接收消息的配置决定收到的值

- 接收消息没有配置 `group`，回调函数 `callback` 参数中的 `group` 为 `undefined`
- 接收消息 `token` 不为 `true`，回调函数 `callback` 参数中的 `token` 为 `undefined`

> 也就意味着，即便发送消息时通过 `global` 发送到“公屏“，同时也提供了 `group` 和 `token`，但接收方没有配置，那么回调函数中 `group` 和 `token` 为 `undefined`

### `debug`：调试方法

接收的参数来自 `zod` 校验失败后的对象

```typescript
type ResultType<Schema = unknown> = Omit<z.ZodSafeParseError<Schema>, 'data'> & {
  data: unknown;
};
```

### `emit`：发送消息的方法

送消息方法的参数类型如下：

<TableList
  data={[
    {
      desc: '发送的消息内容，可以是任意值，这里作为泛型进行收集。只有接收方匹配才能收到消息',
      keyname: 'detail',
      type: ['Detail', 'undefined'],
    },
    {
      desc: '用于群组成员是否发送消息到公屏',
      keyname: 'global',
      type: ['boolean', 'undefined'],
    },
    {
      desc: '接收消息的事件名',
      keyname: 'name',
      type: ['Name'],
    },
    {
      desc: '接收事件消息的密钥',
      keyname: 'token',
      type: ['string', 'undefined'],
    },
  ]}
/>

额外说明：

- `__origin`、`type` 将根据 `useEventChat` 配置自动添加
- `id` 为内部生成
- `group`、`token` 仅用于接收方比对，接收方最终根据自身配置，透传给 `callback` 作为参数

## 只接收指定类型的消息

通过 `Zod` 来实现，提供一个 `schema` 后只有类型匹配的消息才会被接收。

<Canvas
  additionalActions={[
    {
      title: 'Pub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/PubSchema.tsx',
          '_blank'
        );
      },
    },
    {
      title: 'Sub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/SubSchema.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={Schema}
  sourceState="none"
/>

提供 `schema` 后回调函数 `callback` 的参数对象中的属性 `detail`，会根据 `schema` 模型定义的规则推断数据类型。只有类型校验通过的数据才会被接收。所以无论消息怎么发，最终接收的一定是约定好的类型。

### 异步消息

`Zod` 是允许异步校验的，这里通过 `async` 来实现，例如：

```typescript
const { emit } = useEventChat('pub-mox', {
  async: true,
  schema: z.string().refine(async (id) => {
    // verify that ID exists in database
    return true;
  }),
  callback: ({ detail }) => {
    // print id is string
    console.log('a----pub-mox', detail.id);
  },
});
```

通过 `Zod` 的 `refine` 可以实现异步或同步的自定义校验规则，例如 `return type === 'customType'`

## 群组消息

设置 `group` 后将只接受来自成员组的组内消息：

<Canvas
  additionalActions={[
    {
      title: 'Pub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/PubSchema.tsx',
          '_blank'
        );
      },
    },
    {
      title: 'Sub in GitHub',
      onClick: () => {
        window.open(
          'https://github.com/cgfeel/event-chat/blob/main/packages/example/src/module/SubSchema.tsx',
          '_blank'
        );
      },
    },
  ]}
  of={Group}
  sourceState="none"
/>

<style>
  {`
  .category-item > a:first-child {
    float: none;
    left: -18px;
    margin-left: 0;
    position: absolute;
    transform: translateY(-50%);
    top: 50%;
  }
  .docs-story, .demo-wrap {
    background-color: #020917;
  }
  .docs-story > div:first-child {
    padding: 0;
    padding-bottom: 22px;
  }
  .floatingList ul {
    margin: 0;
  }
`}
</style>
